# üè• Appointment API - Enterprise Healthcare System

> **Enterprise-grade appointment scheduling system built with Clean Architecture, Domain-Driven Design, and event-driven microservices patterns.**

[![Node.js](https://img.shields.io/badge/Node.js-20+-green.svg)](https://nodejs.org/)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.7+-blue.svg)](https://www.typescriptlang.org/)
[![NestJS](https://img.shields.io/badge/NestJS-11+-red.svg)](https://nestjs.com/)
[![PostgreSQL](https://img.shields.io/badge/PostgreSQL-15+-blue.svg)](https://postgresql.org/)
[![AWS SQS](https://img.shields.io/badge/AWS-SQS-orange.svg)](https://aws.amazon.com/sqs/)
[![Redis](https://img.shields.io/badge/Redis-7+-red.svg)](https://redis.io/)

## üöÄ **Key Features**

- **üîÑ Asynchronous Processing**: SQS with exponential backoff, idempotency keys, and DLQ redrive policies
- **üß± Architecture**: Clean Architecture with DDD modeling (Bounded Contexts, Aggregates, Domain Entities)
- **üõ°Ô∏è Enterprise Security**: Rate limiting, input validation (class-validator), secrets management, and IAM least privilege
- **üìà Scalability**: Auto scaling with backpressure control (batch size, concurrency, visibility timeout)
- **üîí Data Consistency**: Transactional Outbox pattern with Saga orchestration when needed
- **‚ö° Performance**: Circuit breaker for sync calls, timeouts with jitter, Redis caching
- **üîç Observability**: Structured logs + correlation IDs, RED/USE metrics, distributed tracing (OpenTelemetry)
- **üö® Resilience**: DLQ with poison-pill detection, health checks, and graceful fallbacks

## üõ†Ô∏è **Technology Stack**

### **Backend Framework**
- **[Bun Runtime](https://bun.sh/)** - Ultra-fast JavaScript runtime
- **[NestJS 11+](https://nestjs.com/)** - Progressive Node.js framework
- **[TypeScript 5.7+](https://www.typescriptlang.org/)** - Type-safe development

### **Database & Storage**
- **[PostgreSQL 15](https://postgresql.org/)** - Primary database with ACID compliance
- **[Prisma ORM](https://prisma.io/)** - Type-safe database access
- **[Redis 7](https://redis.io/)** - Caching and idempotency store

### **Message Queue & Events**
- **[AWS SQS](https://aws.amazon.com/sqs/)** - Reliable message queuing
- **Event-Driven Architecture** - Asynchronous processing
- **Saga Pattern** - Distributed transaction management

### **Security & Resilience**
- **[Helmet.js](https://helmetjs.github.io/)** - Security headers and CORS
- **[Class Validator](https://github.com/typestack/class-validator)** - Input validation with DTO sanitization
- **Rate Limiting** - Token bucket algorithm with @nestjs/throttler
- **Circuit Breaker** - Failure isolation for synchronous calls (HTTP/gRPC)
- **Idempotency Keys** - Request deduplication with Redis store
- **Secrets Management** - AWS Secrets Manager integration

---

## üèóÔ∏è **System Architecture**

```mermaid
graph TB
    Client[Client Application] --> Gateway[API Gateway]
    Gateway --> Controller[Appointments Controller]
    
    Controller --> UseCase[Enterprise Schedule UseCase]
    UseCase --> Validator[Business Validation]
    UseCase --> Producer[SQS Producer]
    
    Producer --> SQS[AWS SQS Queue]
    SQS --> Consumer[Enterprise Consumer]
    
    Consumer --> Saga[Saga Orchestrator]
    Saga --> Step1[Validate Patient]
    Saga --> Step2[Check Availability]
    Saga --> Step3[Create Appointment]
    
    Step1 --> DB[(PostgreSQL)]
    Step2 --> DB
    Step3 --> DB
    
    Consumer --> DLQ[Dead Letter Queue]
    DLQ --> Retry[Retry Handler]
    
    subgraph Security Layer
        DDoS[DDoS Protection]
        RateLimit[Rate Limiting]
        IdempotencyCache[Redis Cache]
    end
    
    Gateway --> Security
```

### **Clean Architecture with Domain-Driven Design**

```
src/
‚îú‚îÄ‚îÄ domain/              # üèõÔ∏è Business Core (DDD Bounded Context)
‚îÇ   ‚îú‚îÄ‚îÄ entities/        # Aggregates and domain entities  
‚îÇ   ‚îú‚îÄ‚îÄ repositories/    # Repository ports (interfaces)
‚îÇ   ‚îî‚îÄ‚îÄ value-objects/   # Domain value objects and rules
‚îú‚îÄ‚îÄ application/         # üéØ Application Layer (Use Cases)
‚îÇ   ‚îú‚îÄ‚îÄ use-cases/       # Application services and orchestration
‚îÇ   ‚îú‚îÄ‚îÄ dtos/           # Data transfer objects (input/output)
‚îÇ   ‚îî‚îÄ‚îÄ interfaces/      # Application ports (contracts)
‚îú‚îÄ‚îÄ infrastructure/      # üîß Adapters (External Concerns)
‚îÇ   ‚îú‚îÄ‚îÄ database/        # Prisma & repositories
‚îÇ   ‚îú‚îÄ‚îÄ messaging/       # SQS & event handling
‚îÇ   ‚îú‚îÄ‚îÄ config/         # Configuration
‚îÇ   ‚îî‚îÄ‚îÄ security/        # Security implementations
‚îú‚îÄ‚îÄ presentation/        # üì° Controllers & API Layer
‚îÇ   ‚îú‚îÄ‚îÄ controllers/     # REST controllers
‚îÇ   ‚îú‚îÄ‚îÄ middlewares/     # HTTP middlewares
‚îÇ   ‚îî‚îÄ‚îÄ guards/         # Authorization guards
‚îî‚îÄ‚îÄ common/             # üõ†Ô∏è Shared Utilities
    ‚îú‚îÄ‚îÄ decorators/      # Custom decorators
    ‚îú‚îÄ‚îÄ filters/        # Exception filters
    ‚îú‚îÄ‚îÄ interceptors/   # Request/response interceptors
    ‚îú‚îÄ‚îÄ resilience/     # Circuit breaker, retry logic
    ‚îî‚îÄ‚îÄ saga/           # Saga orchestration
```

## üöÄ Fluxo da Aplica√ß√£o

1. **POST /appointments** - Recebe solicita√ß√£o de agendamento
2. **Valida√ß√£o inicial** - Verifica regras b√°sicas (24h, disponibilidade)
3. **Envia para SQS** - Publica mensagem na fila
4. **Consumer processa** - Valida disponibilidade e confirma/rejeita
5. **Notifica√ß√£o** - Informa resultado ao paciente

### üìã Regras de Neg√≥cio

- ‚úÖ Agendamentos devem ser feitos com pelo menos 24h de anteced√™ncia
- ‚úÖ Respeita hor√°rios de trabalho do psic√≥logo
- ‚úÖ Impede conflitos de hor√°rio (mesmo psic√≥logo, mesmo hor√°rio)
- ‚úÖ Retry autom√°tico para falhas de processamento
- ‚úÖ Logs abrangentes para auditoria

## üöÄ Executando o Projeto

### Pr√©-requisitos

- [Bun](https://bun.sh/docs/installation) >= 1.0
- [Docker](https://docs.docker.com/get-docker/) e Docker Compose
- PostgreSQL (ou usar via Docker)
- AWS SQS (ou LocalStack para desenvolvimento)

### üê≥ Via Docker (Recomendado)

```bash
# Clone o reposit√≥rio
git clone <repository-url>
cd appointment-api

# Inicie todos os servi√ßos
docker-compose up -d

# Execute as migra√ß√µes
docker-compose exec app bun db:migrate

# Execute o seed (dados de exemplo)
docker-compose exec app bun db:seed
```

### üíª Desenvolvimento Local

```bash
# Instale as depend√™ncias
bun install

# Configure as vari√°veis de ambiente
cp .env.example .env
# Edite .env com suas configura√ß√µes

# Execute as migra√ß√µes do banco
bun db:migrate

# Execute os seeds (dados de exemplo)
bun db:seed

# Inicie em modo de desenvolvimento
bun run start:dev
```

### üìä Acessando a Aplica√ß√£o

- **API**: http://localhost:3000
- **Swagger Docs**: http://localhost:3000/api
- **Prisma Studio**: `bun db:studio`

## üß™ Testes

```bash
# Testes unit√°rios
bun test

# Testes com coverage
bun test:cov

# Testes em modo watch
bun test:watch

# Testes e2e
bun test:e2e
```

## üì° Endpoints da API

### POST /appointments

Cria uma nova solicita√ß√£o de agendamento.

**Request Body:**
```json
{
  "patientEmail": "patient@example.com",
  "patientName": "John Doe",
  "patientPhone": "+55 11 99999-9999",
  "psychologistId": "clx123456789",
  "scheduledAt": "2024-12-25T10:00:00Z",
  "notes": "First consultation"
}
```

**Response (202 Accepted):**
```json
{
  "appointmentId": "clx987654321",
  "status": "queued",
  "message": "Appointment request has been queued for processing"
}
```

## ‚öôÔ∏è Configura√ß√£o de Ambiente

### Vari√°veis de Ambiente (.env)

```bash
# Database
DATABASE_URL="postgresql://username:password@localhost:5432/appointment_db"

# AWS SQS
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
SQS_APPOINTMENT_QUEUE_URL=https://sqs.us-east-1.amazonaws.com/account/queue

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# Application
NODE_ENV=development
PORT=3000
```

## üìö Scripts Dispon√≠veis

```bash
# Desenvolvimento
bun run start:dev      # Inicia em modo watch
bun run start:debug    # Inicia com debug

# Produ√ß√£o
bun run build         # Compila o projeto
bun run start:prod    # Inicia em produ√ß√£o

# Banco de dados
bun db:migrate        # Executa migra√ß√µes
bun db:seed          # Popula dados de exemplo
bun db:studio        # Abre Prisma Studio
bun db:generate      # Gera cliente Prisma

# Qualidade de c√≥digo
bun run lint         # Executa ESLint
bun run format       # Formata c√≥digo com Prettier
```

## üéØ Princ√≠pios Aplicados

### SOLID
- **SRP**: Cada classe tem responsabilidade √∫nica
- **OCP**: Extens√≠vel via interfaces
- **LSP**: Substitui√ß√£o de implementa√ß√µes
- **ISP**: Interfaces espec√≠ficas por contexto  
- **DIP**: Inje√ß√£o de depend√™ncia

### Clean Architecture Layers
- **Domain Layer**: Aggregates, entities, value objects e regras de neg√≥cio (DDD)
- **Application Layer**: Use cases, DTOs e interfaces (ports)
- **Infrastructure Layer**: Implementa√ß√µes concretas (adapters) para Prisma, SQS, HTTP
- **Presentation Layer**: Controllers, middlewares e valida√ß√£o de entrada

### Design Patterns
- **Repository Pattern**: Abstra√ß√£o do acesso a dados (Ports/Adapters)
- **Transactional Outbox**: Eventos e dados persistidos na mesma transa√ß√£o
- **Saga Pattern**: Orquestra√ß√£o de transa√ß√µes distribu√≠das quando necess√°rio
- **Circuit Breaker**: Isolamento de falhas em chamadas s√≠ncronas

## üîß **Implementa√ß√£o Pr√°tica (NestJS/TypeScript)**

### **Correlation ID & Observability**
```typescript
// Middleware que injeta x-correlation-id e propaga para logs/SQS
@Injectable()
export class CorrelationIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    req.correlationId = correlationId;
    res.setHeader('x-correlation-id', correlationId);
    next();
  }
}
```

### **Idempotency com Redis**
```typescript
// Deduplica√ß√£o de handlers SQS e requests HTTP
@Injectable()
export class IdempotencyService {
  async processWithIdempotency(key: string, handler: () => Promise<any>) {
    const existing = await this.redis.get(`idempotency:${key}`);
    if (existing) return JSON.parse(existing);
    
    const result = await handler();
    await this.redis.setex(`idempotency:${key}`, 3600, JSON.stringify(result));
    return result;
  }
}
```

### **SQS com Exponential Backoff**
```typescript
// maxReceiveCount na redrive + visibility timeout ajustado
consumers: [{
  name: 'appointment-consumer',
  queueUrl: process.env.SQS_QUEUE_URL,
  batchSize: 10,
  visibilityTimeoutSeconds: 300, // 5min para processamento
  maxReceiveCount: 3, // Ap√≥s 3 tentativas ‚Üí DLQ
}]
```

### **Transactional Outbox Pattern**
```typescript
// Persistir evento e dados na mesma transa√ß√£o
async createAppointment(data: CreateAppointmentDto) {
  return this.prisma.$transaction(async (tx) => {
    const appointment = await tx.appointment.create({ data });
    
    // Evento persistido na mesma transa√ß√£o
    await tx.outboxEvent.create({
      data: {
        eventType: 'APPOINTMENT_CREATED',
        aggregateId: appointment.id,
        payload: JSON.stringify(appointment)
      }
    });
    
    return appointment;
  });
}
```

## üîß Justificativa T√©cnica

### Por que SQS ao inv√©s de RabbitMQ?
- **Managed Service**: Menos overhead operacional
- **Escalabilidade**: Auto-scaling nativo da AWS
- **Integra√ß√£o**: Melhor integra√ß√£o com ecossistema AWS
- **Confiabilidade**: SLA garantido pela AWS
- **Dead Letter Queue**: Tratamento de mensagens falhas

## üêõ Troubleshooting

### Problemas Comuns

**Erro de conex√£o com banco:**
```bash
# Verifique se o PostgreSQL est√° rodando
docker-compose ps postgres

# Refa√ßa as migra√ß√µes
bun db:migrate
```

**SQS n√£o funciona:**
```bash
# Para desenvolvimento local com LocalStack
docker-compose logs localstack

# Verifique se a fila foi criada
aws --endpoint-url=http://localhost:4566 sqs list-queues
```

## üìà Monitoramento e Logs

A aplica√ß√£o utiliza o sistema de logs do NestJS com diferentes n√≠veis:
- **LOG**: Opera√ß√µes normais
- **WARN**: Situa√ß√µes de aten√ß√£o
- **ERROR**: Erros que precisam investiga√ß√£o

## ü§ù Contribuindo

1. Fork o projeto
2. Crie uma branch para sua feature (`git checkout -b feature/amazing-feature`)
3. Commit suas mudan√ßas (`git commit -m 'Add: amazing feature'`)
4. Push para a branch (`git push origin feature/amazing-feature`)
5. Abra um Pull Request

## üìÑ Licen√ßa

Este projeto est√° sob licen√ßa MIT. Veja o arquivo [LICENSE](LICENSE) para mais detalhes.

## üë®‚Äçüíª Autor

Desenvolvido por [Ness](https://github.com/Felipeness) para revisar e aplicar conceitos de Clean Architecture, SOLID, e Event-Driven Design.